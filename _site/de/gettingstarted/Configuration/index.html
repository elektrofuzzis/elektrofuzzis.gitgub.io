<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.24.0 by Michael Rose
  Copyright 2013-2020 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->
<html lang="en" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>Konfiguration -</title>
<meta name="description" content="The ftSwarm Project connects multiple controllers in DIY roboticy projects.">


  <meta name="author" content="The ftSwarm Project">
  


<meta property="og:type" content="website">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="">
<meta property="og:title" content="Konfiguration">
<meta property="og:url" content="http://localhost:4000/de/gettingstarted/Configuration/">


  <meta property="og:description" content="The ftSwarm Project connects multiple controllers in DIY roboticy projects.">











  

  


<link rel="canonical" href="http://localhost:4000/de/gettingstarted/Configuration/">




<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    
      "@type": "Person",
      "name": "The ftSwarm Project",
      "url": "http://localhost:4000/"
    
  }
</script>







<!-- end _includes/seo.html -->



  <link href="/feed.xml" type="application/atom+xml" rel="alternate" title=" Feed">


<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css"></noscript>



    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->

  </head>

  <body class="layout--category wide">
    <nav class="skip-links">
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    
<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
          <a class="site-logo" href="/"><img src="/assets/img/ftSwarm.svg" alt=""></a>
        
        <a class="site-title" href="/">
          
          
        </a>

        <!-- original stuff 
        <ul class="visible-links"></ul>
        end original stuff-->

        <script>
          function callRef( url ) {
            if ( location.pathname.startsWith('/en/') ) {
              location.href='/en/'+url;
            } else {
              location.href='/de/'+url;
            }
          }
        </script>

        <ul class="visible-links">
          <li class="masthead__menu-item">
            <a href="#" onclick="callRef('gettingstarted/gettingstarted')" title="Manual">Manual</a>
          </li>
          <li class="masthead__menu-item">
            <a href="#" onclick="callRef('cpp-api/index')" title="api">api</a>
          </li>
          <li class="masthead__menu-item">
            <a href="#" onclick="callRef('products/index')" title="Products">Products</a>
          </li>
          <li class="masthead__menu-item">
            <a href="#" onclick="callRef('faq')" title="FAQ">FAQ</a>
          </li>
        </ul>


        <!-- language picker -->

        <a class="alang" href="#" onclick="location.href=location.href.replace('/de/', '/en/')"><img class="language-picker" src="/assets/img/uk.png"></a>
        <a class="alang" href="#" onclick="location.href=location.href.replace('/en/', '/de/')"><img class="language-picker" src="/assets/img/germany.png"></a>
        
        <!-- language picker -->

        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      



<div id="main" role="main">
  
  <div class="sidebar sticky">
  
  
    
      
      
      
      
    
    
      

<nav class="nav__list">
  
  <input id="ac-toc" name="accordion-toc" type="checkbox" />
  <label for="ac-toc">Toggle menu</label>
  <ul class="nav__items">
    
      <li>
        
          <span class="nav__sub-title">Manual</span>
        

        
      </li>
    
      <li>
        
          <span class="nav__sub-title">Inbetriebnahme</span>
        

        
        <ul>
          
            <li><a href="/de/gettingstarted/pinout">Anschlüsse</a></li>
          
            <li><a href="/de/gettingstarted/serial">USB Anschluss</a></li>
          
            <li><a href="/de/gettingstarted/WebUI">WLAN & Statusseite</a></li>
          
            <li><a href="/de/gettingstarted/ide">Installation IDE</a></li>
          
        </ul>
        
      </li>
    
      <li>
        
          <span class="nav__sub-title">Programmierung</span>
        

        
        <ul>
          
            <li><a href="/de/gettingstarted/MotorSwitch">Das erste Programm</a></li>
          
            <li><a href="/de/gettingstarted/kelda">Das Kelda Prinzip</a></li>
          
            <li><a href="/de/gettingstarted/MotorSwitchSwarm">Ein erster Schwarm</a></li>
          
            <li><a href="/de/gettingstarted/MotorSwitchAlias">Alias Namen</a></li>
          
            <li><a href="/de/gettingstarted/switches">Switches & Buttons</a></li>
          
            <li><a href="/de/gettingstarted/RemoteControl">Fernbedienung</a></li>
          
            <li><a href="/de/gettingstarted/EventControlled">Events</a></li>
          
            <li><a href="/de/gettingstarted/FtSwarmPixel">RGB LEDs & FtSwarmPixel</a></li>
          
            <li><a href="/de/gettingstarted/FtSwarmOLED">OLED Display</a></li>
          
        </ul>
        
      </li>
    
      <li>
        
          <span class="nav__sub-title">Firmware</span>
        

        
        <ul>
          
            <li><a href="/de/gettingstarted/firmware">Firmware & Updates</a></li>
          
            <li><a href="/de/gettingstarted/versions">Versionen</a></li>
          
        </ul>
        
      </li>
    
      <li>
        
          <span class="nav__sub-title">Advanced</span>
        

        
        <ul>
          
            <li><a href="/de/gettingstarted/Configuration">Konfiguration</a></li>
          
            <li><a href="/de/gettingstarted/PlatformIO">PlatformIO & VSCode</a></li>
          
            <li><a href="/de/gettingstarted/rs485">RS485</a></li>
          
            <li><a href="/de/gettingstarted/debugging">Debugging</a></li>
          
        </ul>
        
      </li>
    
  </ul>
</nav>

    
  
  </div>



  <div class="archive">
    
      <h1 id="page-title" class="page__title">Konfiguration</h1>
    
    <p>Die Controller benötigen einige Einstellungen, wie z.B. ein WLAN-Profil oder auch die Konfiguration des Swarms. Einige Einstellungen wurden bereits im Tutorial verwendet. Dieses Kapitel beschreibt alle Konfigurationsmöglichkeiten im Detail.</p>

<p>Zur Konfiguration des Controllers kann in der Standardfirmware jederzeit das “Configuration Menu” gestartet werden. Dazu muss nur ein Terminal Programm verbunden werden nur eine Taste gedrückt werden. Das Configuration Menu kann mit</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">firmware</span><span class="p">();</span>
</code></pre></div></div>

<p>jederzeit aufgerufen werden.</p>

<hr />

<h3 id="main-menu">Main Menu</h3>

<p>Das <strong>Main Menu</strong> ist die oberste Ebene der Konfigurationsmenüs.  <strong>(0) exit</strong> beendet den Konfigurationsmodus, in der Standardfirmware bootet danach der Controller neu. Wurde das <strong>Main Menu</strong> mit <strong>ftSwarm.setup();</strong> aus einem Programm heraus aufgerufen, so werden nun die nächsten Kommandos im Programm ausgeführt.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Main Menu

(1) wifi &amp; Web UI
(2) swarm configuration
(3) alias names
(4) factory reset
(5) remoteControl
(6) extention port

(0) exit
</code></pre></div></div>

<p>Beim <em>ftSwarmControl</em> gibt es einen zusätzlichen Menüpunkt um den Displaytyp einzustellen und die Joysticks zu kalibrieren.</p>

<hr />

<h3 id="wifi--web-ui">Wifi &amp; Web UI</h3>

<p>In diesem Bereich werden die WLAN-Einstellungen vorgenommen und die Statusseite der Controller konfiguriert.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Wifi &amp; WebUI

(1) wifi:           AP-Mode
(2) SSID:           ftSwarm100
(3) Password:       *****
(4) Web UI:         on
(5) ftPixels in UI: 2
</code></pre></div></div>

<p>Um einen Swarm zu bilden, müssen die einzelnen Controller miteinander über WLAN oder RS485 kommunizieren. In der Regel kommunizieren sie über WLAN - nur die ftSwarmRS können zusätzlich kabelgebunden über RS485 kommunizieren.</p>

<p>Außerdem kann über WLAN die Statusseite der Controller aufgerufen werden.</p>

<p>Mit der Option <strong>(1) wifi</strong> wird der WLAN-Typ festgelegt:</p>
<ul>
  <li>CLIENT-MODE nutzt ein vorhandenes WLAN. Im Regelfall ist dies das WLAN Ihres Internetrouters.</li>
  <li>AP-MODE benötigt keinen Router, der ftSwarm-Controller erzeugt ein eigenes WLAN Netzwerk.</li>
  <li>OFF schaltet WLAN aus (nur ftSwarmRS) und reduziert deutlich den Stromverbrauch.</li>
</ul>

<p>Ist ein WLAN bereits vorhanden, so sollten Sie dieses unbedingt verwenden. Wählen Sie dazu CLIENT-MODE und setzen Sie mit <strong>SSID</strong> und <strong>password</strong> die Zugangsdaten zu Ihrem WLAN. Mit <strong>exit</strong> speichern Sie die Daten im NVS des Controllers und er verbindet sich mit Ihrem WLAN indem er neu startet.</p>

<p>Der <strong>AP-MODE</strong> ist ein wenig tricky:</p>
<ul>
  <li>Wählen Sie einen Controller im geplanten Swarm aus und schalten Sie dort auf AP-MODE. Mit <strong>SSID</strong> geben Sie dem WLAN einen Namen. Aufgrund von Einschränkungen von espressif, sind WLANs im AP-MODE immer offene WLANs und es wird kein Passwort benötigt.</li>
  <li>Zusätzlich müssen Sie mit Option <strong>wifi channel</strong> den Kanal auswählen, auf dem Ihre SSID arbeitet.</li>
  <li>Alle anderen Controller werden auf CLIENT-MODE gestellt. Die SSID ist die des obigen Controllers; setzen Sie ein leeres Password.</li>
  <li>Setzen Sie nie die Kelda in den AP-MODE. Wie im Tutorial beschrieben, führt dies zu einigen Problemen beim flushen Ihres Programms.</li>
  <li>Der AP-MODE hat einen hohen Stromverbrauch, das Netzwerk ist für jeden offen (es hat kein Password) und der Sendebereich ist sehr beschränkt.</li>
</ul>

<p>Die Option <strong>off</strong> kann nur am ftSwarmRS gesetzt werden. In diesem Fall muss Ihr Swarm komplett über RS485 kommunizieren.</p>

<p class="notice--info">Die WLAN-Kanäle teilen Sie mit anderen WLANs. Deshalb ist es wichtig, den “richtigen” Kanal auszuwählen. Die ESP32-Prozessoren verwenden das 2.4 GHz-Band. Dieser Bereich ist in 11 Kanäle aufgeteilt, dabei überlappen sich benachbarte Kanäle. Werden zwei benachbarte Kanäle durch ein WLAN verwendet, so stören diese sich gegenseitig. Deshalb ist es im 2.4GHz-Band am Besten, wenn alle WLANs nur die Kanäle 1, 6 und 11 verwenden. Optimalerweise gibt es einen nicht verwendeten Kanal. Ist dieser nicht verfügbar, so nutzen Sie einen bereits verwendeten Kanal dessen Nachbarkanäle nicht in Verwendung sind. Welche Kanäle bereits verwendet sind, können Sie sich auf dem meisten Internetroutern anzeigen lassen. Mit der App <a href="https://play.google.com/store/apps/details?id=com.ubnt.usurvey&amp;hl=de&amp;gl=US&amp;pli=1">wifiman</a> können Sie das auch über Ihr Smartphone analysieren.</p>

<p>Die letzten beiden Optionen legen das Verhalten der Statusseite fest.</p>

<ul>
  <li><strong>WebUI: on/off</strong> schaltet den WEB-Server für die Statuspage ein bzw aus.</li>
  <li><strong>Show X ftPixels in UI</strong> legt die Anzahl der ftPixel fest, die auf der Statuspage angezeigt werden, bzw. die im Menu “Alias Names” einen Namen zugewiesen bekommen können. Für die Programmierung von ftPixel über die Port-Nummer hat dieser Wert keinen Einfluss, es können immer alle Ports <strong>FTSWARM_LED1</strong> bis <strong>FTSWARM_LED18</strong> angesprochen werden.</li>
</ul>

<hr />

<h3 id="swarm-configuration">Swarm Configuration</h3>

<p>In diesem Menü wird der Swarm gebildet. Bevor Sie einen Swarm bilden können, müssen alle Controller untereinander kommunizieren können. Dazu müssen entweder alle Controller im gleichen WLAN angemeldet sein, oder über RS485 verbunden sein.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>swarm configuration

This device is connected to swarm "mySwarm" with 1 member(s) online.
Swarm PIN is 123.
(1) Kelda:               this controller
(2) swarm communication: wifi
(3) create a new swarm
(4) list swarm members
</code></pre></div></div>

<p>Das Beispiel zeigt das Menü der Kelda.</p>

<p><strong>(1) Kelda</strong> stellt ein, ob der Controller als Kelda oder als Swarm Member betrieben wird. Bitte beachten Sie, dass Ihr Steuerprogramm oder die Python-Integration immer auf der Kelda laufen müssen.</p>

<p><strong>(2) swarm communication</strong> stellt ein, über welches Medium die ftSwarm miteinander kommunizieren.</p>
<ul>
  <li><strong>wifi</strong>: die Controller nutzen WLAN.</li>
  <li><strong>RS485</strong>: die Controller nutzen die RS485-Schnittstelle. Diese Option steht nur am fTSwarmRS zur Verfügung. Ein Mixed-Mode mit WLAN und RS485 ist nicht möglich.</li>
</ul>

<p><strong>(3) create a new swarm</strong> ist nur auf der Kelda möglich und erzeugt einen neuen Swarm. Es werden der Name für den Swarm und die PIN abgefragt. Anschließend ist dieser Controller der erste und (noch) einzige Controller im Swarm.</p>

<p><strong>(3) join another swarm</strong> gibt es nur auf swarm membern und fügt den Controller zu einem existierenden Swarm hinzu. Es werden der Name des Swarms und die PIN abgefragt. Der Controller versucht sich dann mit dem Swarm zu verbinden, dazu muss der Kelda Controller des Swarms online sein.</p>

<p><strong>(4) list swarm members</strong> ist nur auf der Kelda möglich und listet alle Mitglieder des Swarms auf, die online sind.</p>

<p class="notice--info">Jeder Controller hat den Namen des Swarms und die Swarm-PIN in seinem Flash-Speicher gespeichert. Die Namen der anderen Controller im Swarm werden nicht gespeichert, jeder der den Namen des Swarms und die PIN kennt kann jederzeit dem Swarm beitreten. Deshalb ist keine Option für das Verlassen eines Swarms notwendig.</p>

<hr />

<h3 id="alias-names-settings">Alias Names Settings</h3>

<p>Mit diesem Menü können Aliasnamen für die Ports eingestellt werden. Anschließend können die IO-Ports über den logischen Namen anstatt der Portnummer angesprochen werden. Im Tutorial ist dies im Kapitel <a href="../gettingstarted/MotorSwitchAlias/">Alias Names</a> näher erklärt.</p>

<p>Um einen Aliasnamen für einen IO Port zu vergeben, wählen Sie die Nummer des gewüschten IOs aus. Der Name darf bis zu 30 Zeichen lang sein und darf keine Leerzeichen enthalten.</p>

<p class="notice--info">In einem Swarm muss ein Aliasname eindeutig sein. Dies wird bei der Konfiguration nicht geprüft - es müssen nicht alle Controller im Swarm online sein. Wird ein Name mehrfach vergeben, so ist es Zufall welcher IO-Port beim Benutzen des Aliasnamens angesprochen wird.</p>

<hr />

<h3 id="factory-reset">Factory Reset</h3>

<p>Dieser Menüpunkt stellt den Controller auf Werkseinstellungen zurück. Da im Flash evtl. vertrauliche Informationen wie die wifi-Parameter gespeichert sind, sollten Sie einen Controller auf Werkseinstellungen zurücksetzten, bevor sie ihn an Dritte weitergeben.</p>

<hr />

<h3 id="remote-control-settings">Remote Control Settings</h3>

<p>Mit diesem Menü kann ein Swarm ohne eine Zeile Code programmiert werden. Dazu bekommen die einzelnen IO-Ports Aliasnamen, die dann über den ftSwarmControl angesprochen werden. Dazu werden auf den Buttons und Joysticks des ftSwarmControl EVents definiert, die die IO Ports steuern.</p>

<p>Eine detaillierte Beschreibung ist im Tutorial unter <a href="../gettingstarted/RemoteControl/">Fernbedieung</a> zu finden.</p>

<hr />

<h3 id="extention-port">Extention Port</h3>

<p>Die Controller verfügen über einen Extention Port, an den externe Hardware angeschlossen werden kann.</p>

<p>Der Anschluß ist im Gegensatz zu den anderen Anschlüssen des Controllers nicht gegen Überspannung oder Verpolung geschützt.</p>

<p><strong>ftSwarm:</strong> Der Extention Port ist die Steckerleiste an der Oberseite des Controllers.</p>
<ul>
  <li>An diesem Port kann der optionale MC6040-Gyro angeschlossen werden.</li>
  <li>Alternativ kann der Port als I²C-Bus (als Master oder als Slave) betrieben werden.</li>
  <li>Als dritte Möglichkeit können die beiden IO-Pins als logische “Motorausgänge” geschaltet werden. Bitte beachten Sie, dass es reine GPIO-Pins sind die keine Last schalten können. Um Motoren, Relais oder Lampen anzuschließen benötigen Sie zusätzliche externe Leistungstreiber.</li>
</ul>

<p><strong>ftSwarmRS:</strong> Der Extention Port ist die 4-polige Stiftleister an der Oberseite des Controllers.</p>
<ul>
  <li>Der Port kann als I²C-Bus (als Master oder als Slave) betrieben werden.</li>
  <li>Als zweite Möglichkeit können die beiden IO-Pins als logische “Motorausgänge” geschaltet werden. Bitte beachten Sie, dass es reine GPIO-Pins sind die keine Last schalten können. Um Motoren, Relais oder Lampen anzuschließen benötigen Sie zusätzliche externe Leistungstreiber.</li>
</ul>

<p>Der interne Gyro des ftSwarmRS verwendet einen eigenen I²C-Bus.</p>

<p><strong>ftSwarmControl</strong>: 
Der Port kann nur als I²C-Bus betrieben werden. Da an diesem Bus auch das OLED-Display und der optionale Gyro angeschlossen sind, kann er nur im Master-Mode betrieben werden. Im Gegensatz zu den beiden anderen Controllern können sowohl 3.3V- als auch 5V-Sensoren angeschlossen werden.</p>

<p><strong>(1) Mode</strong> legt den Betriebsmodus des Extention Ports fest.</p>
<ul>
  <li><strong>off</strong> schaltet den Port aus.</li>
  <li><strong>I2C-Master</strong> schaltet den Port als I²C-Bus. Der Controller ist Busmaster. Verwenden Sie diese Option, wenn Sie I²C-Sensoren anschließen wollen.</li>
  <li><strong>I2C-Slave</strong> schaltet den Port ebenfalls als I²C-Bus. Der Controller ist in diesem Fall Slave. Diese Funktion kann z.B. dazu verwendet werden um Daten mit einem TXT-Controller auszutauschen.</li>
  <li><strong>Gyro MCU6040</strong> aktiviert beim <em>ftSwarmControl</em> bzw. beim <em>ftSwarm</em> den optionalen Gyro.</li>
  <li><strong>Outputs</strong> ist nur beim <em>ftSwarm</em> und <em>ftSwarmRS</em> möglich. Die beiden IO-Pins des Extention Ports können dann softwareseitig als Motorausgänge angesprochen werden. An den IO-Pins liegt dann ein PWM-Signal entsprechend dem eingestellten Speed-Wert des Motorausgangs an. Bitte beachten Sie, dass der IO-Pin nur ein 3.3V-Logikpegel liefert und ohne Zusatzhardware keine Aktoren schalten kann.</li>
</ul>

<p><strong>Gyro</strong> schaltet die Verwendung des Gyros ein bzw. aus. Schalten Sie den Gyro nur ein, wenn Sie ihn in der Anwendung auch nutzen wollen. Ungenutzte Gyros haben einen unnötigen Stromverbrauch und im Swarm einen hohen Kommunikationsbearf.</p>

<p><strong>I2C Address</strong> legt die I²C-Adresse des Controllers im SLAVE-Modus fest. Diese Option steht im MASTER-Modus nicht zur Verfügung.</p>

<hr />

<h3 id="ftswarmcontrol">ftSwarmControl</h3>

<p>Der ftSwarmControl hat zwei spezifische Einstellungen.</p>

<p><strong>Display Type</strong>: Je nach verwendetem OLED-Display unterscheidet sich die Ansteuerung der OLEDs auf Firmwareebene ein wenig. Die ersten ftSwarmControl benötigen den Display Typ 0, die neueren Typ 1. Sollte das Display des ftSwarmControl nicht funktionieren, stellen Sie hier einen anderen Wert ein.</p>

<p><strong>Calibrate Joysticks</strong>: Die Joysticks liefern ein analoges Signal. Mit Calibrate Joysticks kann die mittlere Stellung des Joysticks kalibriert werden.</p>




<div class="entries-list">
  
</div>

  </div>
</div>
    </div>

    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    
      <li><strong>Follow:</strong></li>
    

    
      
        
      
        
      
        
          <li><a href="https://github.com/elektrofuzzis" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub</a></li>
        
      
        
      
        
      
        
          <li><a href="https://instagram.com/elektrofuzzies" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-instagram" aria-hidden="true"></i> Instagram</a></li>
        
      
        
          <li><a href="mailto:ftpi@gmx.de" rel="nofollow noopener noreferrer"><i class="fas fa-fw fa-envelope-square" aria-hidden="true"></i> Email</a></li>
        
      
    

    
      <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
    
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2024 The ftSwarm Project. Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>










  </body>
</html>
